* Racket questions

** bind an unbound id in a macro

[[https://groups.google.com/forum/#!topic/racket-users/ztrOjIIxSjs][Asked on list]]

*** Problem

Here's what I've been trying and failing to do in Racket. The smallest example I
could think of is a macro that sets a key in a hash-table, so basically this
transformation:

#+begin_src racket
  (set/define ht 'key 42)
  ;; =>
  (hash-set! ht 'key 42)
#+end_src

but if ht there is an unbound identifier it must bind it to a fresh hash table. So
basically introduce a (define ht (make-hash)) before setting the key. Assume we
run in a context where define is allowed.

Please, don't ask why I want something like this, I just do. So far tricks I could
use in other lisps failed in Racket. Here's one silly idea: catch unbound
identifier exn. You can do it as per below or in the handler itself but it doesn't
matter cause that define is local (I think) and doesn't happen in the macro use
context.

#+begin_src racket

  (require (only-in syntax/macro-testing convert-compile-time-error))

  (define (unbound-id-error? err)
    (and (exn:fail:syntax? err)
         (regexp-match #rx"unbound identifier" (exn-message err))))

  (define-syntax-rule (set/define id key val)
    (unless (let/ec k
              (with-handlers ((unbound-id-error? (λ (_) (k #f))))
                (convert-compile-time-error
                 (hash-set! id key val))))
      (displayln "escaped")
      (define id (make-hash))
      (hash-set! id key val)))

  (set/define ht 'key 42)
  ;; =>
  ;; runs but appears that the (define ht ..) doesn't happen at top-level

#+end_src

This is already all sorts of ugly and it doesn't even work.

Another idea is to replace #%top for the extent of that transformer, perform
local-expand (or some equivalent) so that #%top expansion does the job. I've no
idea how to do that, but I'm sure Racket could be persuaded. Incidentally, I'm
curious how to create such local transformers e.g. something like (let-transformer
((#%top ...)) body).

Even if I knew how to do the above (local-expand #'(set/define ht 'key 42) '())
run at compile time doesn't seem to wrap unbound ht in #%top. I thought it should?

So then, two questions:

1. What's the Racket way of getting what I want?

2. Is there a way to torture the above code into submission? Put differently is
   there a way to ensure (define id (make-hash)) runs in appropriate context? 

** cycle in loading

[[https://groups.google.com/forum/#!topic/racket-users/DKfWFGJVckU][Asked on the list]]

*** Problem

I wrote a library foo/bar.rkt and I also allow to use it as a #lang. Roughly the
structure is like this:

foo
├── bar
│   ├── lang
│   │   └── reader.rkt
│   └── main.rkt
├── bar.rkt

Most of the work happens in the library foo/bar.rkt, so naturally all of the tests
reside there. I'd like to be able to test library proper, but also use the syntax
of the language that I defined for it, so I try something like this and get a ...
cycle? Sadly, I can't figure out why. Could you please help me reason through
this.

#+begin_src racket
  ;; foo/bar.rkt
  ;; -----------
  ;; bulk of foo/bar language semantics is here, but we also want to allow
  ;; requiring it as a library, hence this file and module indirection
  (module+ test

    (module lang-test foo/bar
      (provide run-language-tests)
      (define (run-language-tests) 42))

    (define run (dynamic-require 'lang-test 'run-language-tests))
    (run))

  ;; => error
  ;
  ; standard-module-name-resolver: cycle in loading
  ;   at path: /Users/russki/Code/foo/bar.rkt
  ;   paths:
  ;    /Users/russki/Code/prelude/bar.rkt

#+end_src

Far as I can tell cycle isn't due to dynamic-require there, but due to that
submodule declaration. This puzzles me, since the submod is declared with module,
not module+ or module*.

Other modules look as you'd probably expect:

#+begin_src racket
  ;; foo/bar/lang/reader.rkt
  ;; -----------------------
  #lang s-exp syntax/module-reader
  foo/bar/main

  ;; foo/bar/main.rkt
  ;; ----------------
  #lang racket
  (require foo
           "../bar.rkt")

  (provide (except-out (all-from-out foo) #%app #%top)
           (rename-out [app #%app]
                       [top #%top])
           (except-out (all-from-out "../bar.rkt") app top))
#+end_src


Now, if we move the lang tests into a separate file, the dynamic-require above
works out and no cycles are reported:

#+begin_src racket
;; foo/lang-test.rkt
;; -----------------
#lang foo/bar
(provide run-language-tests)
(define (run-language-tests) 42)
#+end_src

One hypothesis I have is that the (module lang-test foo/bar ...) doesn't resolve
to the language but rather to the foo/bar.rkt. There must be a way to reflect how
resolver works, but the closest I found was this:

#+begin_src racket
(require syntax/modresolve)
(resolve-module-path 'foo/bar)
#+end_src

And indeed it resolves to foo/bar.rkt, but then I don't know if I'm even using it
correctly.

I may actually be doing something stupid here e.g. introducing ambiguity as to how
foo/bar is resolved (lang or lib) but this silliness brings about some things I'd
like to clarify and learn:

1. How would you write your tests in the situation like this when most of the work
   happens in the library but you also allow using it as #lang? I'd like to keep
   both kinds of tests local to the library, so I can run them as code. Or at
   least be able to run tests that only test the lib and corresponding language.

2. Why does the above report a cycle? How do I reason about it, better still how
   do I query the resolver, reflect and debug?


Have I missed some important part in the docs about this?

PRELUDE  -*- mode: org; fill-column: 82 -*-
#+CATEGORY: prelude
#+STARTUP: content
#+seq_todo: TODO STARTED(s/@) WAITING(w@/@) DELEGATED(l@/@) APPT | DONE(d@/@) DEFERRED(f@/@) CANCELLED(x@/@) IDEA(i/@)
#+TAGS: { SCHOOL(s) BLOG(b) TIL(t) }
#+PROPERTY: Effort_ALL 0 0:10 0:30 1:00 2:00 3:00 4:00 5:00 6:00 7:00
#+COLUMNS: %30ITEM(Task) %CLOCKSUM %15Effort(Effort){:}

* Prelude

** DONE Move tables.rkt out of prelude
CLOSED: [2019-06-23 Sun 12:52] SCHEDULED: <2019-06-23 Sun>
- State "DONE"       from "STARTED"    [2019-06-23 Sun 12:52] \\
  Tables now live in their own multi package and collection.
:LOGBOOK:
CLOCK: [2019-06-23 Sun 12:27]--[2019-06-23 Sun 12:52] =>  0:25
:END:

we'd like to have #lang racket/tables so tables.rkt should probably be in its own
package and we'd want to require and re-export it from racket/racket collection?
Ditto prelude if I have to.

** DONE Move undefined aware logic ops from prelude to tables.rkt
CLOSED: [2019-06-23 Sun 12:17] SCHEDULED: <2019-06-23 Sun>
- State "DONE"       from "STARTED"    [2019-06-23 Sun 12:17] \\
  Prelude doesn't really depend on undefined aware logic, so we broke the loading
  cycle. Logic ops now live in the 'logic submod in tables.rkt
- State "TODO"       from "STARTED"    [2019-06-23 Sun 12:07] \\
  I moved logic combinators to a separate logic.rkt for now to avoid cycle in
  loading. Ideally I want logic to be a submodule of tables.rkt probably.
:LOGBOOK:
CLOCK: [2019-06-23 Sun 12:11]--[2019-06-23 Sun 12:17] =>  0:06
CLOCK: [2019-06-23 Sun 11:22]--[2019-06-23 Sun 12:07] =>  0:45
:END:

** DONE consider undefined friendly or? and? semantics
CLOSED: [2019-06-05 Wed 10:50]

- State "DONE"       from "TODO"       [2019-06-05 Wed 10:50] \\
  ATM or? skips any internal undefined as if it were #f but returns the final
  expression if reached, so it could be undefined; and? short circuits the moment it
  sees #f or undefined returning undefined in the latter case. This is consistent
  with default Racket or and, however they cannot be mixed with or? and? combinators
  since the former treat undefined as #t. Effectively or? and? implement ternary
  logic or something. To use the result of or? and? combinators in Racket's ~or~
  ~and~ the results must be wrapped in e.g. ~some?~ who always returns #t or #f.
  That raises the question of consistency: shouldn't some? return undefined? I am a
  bit wary of the whole thing but it does let me avoid contaminating code with
  checks for undefined.
this is subtle but when used with tables that return ~undefined~ on key missing
both or? and and? must return the last argument without wrapping it in some? -
that is the resut should not be converted to boolean #t or #f. If it happens to be
undefined then that is what's returned. It may make for better semantics in
context of tables, however this would make these forms infectios, so you wouldn't
be able to mix them with normal Racket boolean forms. Should we have or/undefined
and and/undefined instead?

It is almost like I'm proposing teriary logic, sigh.

** DONE :tag trick
CLOSED: [2019-04-29 Mon 15:50]

by wrapping them in #%datum.

We'll call them tags.

+Maybe Racket printer could be coerced to print ':foo as :foo? This only really
ever matters in REPL and logging, I guess.+

#+begin_note
Racket printer tries to move quote outside of any compound datum like list,
vector, table, so :tags rarely print with prepended quote.
#+end_note

I don't think we should prohibit binding tag-like identifiers. If its bound, so be
it, just use the binding. User should know what they are doing.

*** DONE syntax highlight :tags in racket-mode
CLOSED: [2019-04-29 Mon 16:01]

Sadly, appears that order of highlighting rules for Racket matters and if I
merrily add one for :tags with ~font-lock-add-keywords~ it breaks all of Racket
highlighting. Had to hardcode the rule in /racket-font-lock.el/ so now tags use
~racket-selfeval-face~, which I don't mind.

*** IDEA consider ~font-lock-builtin-face~ for :tags in suffix position
CLOSED: [2019-05-18 Sat 13:36]

One thing we could do to further improve readability is to tweak the regexp so
that any foo:bar highligts :bar part as say ~font-lock-builtin-face~.

** DONE ~> macro
CLOSED: [2019-05-18 Sat 13:18]

- State "DONE"       from "TODO"       [2019-05-18 Sat 13:18] \\
  See tilda project
#+begin_src racket
  (~> bar
      #:guard defined?
      (foo ~)
      #:guard dict?
      (get ~dict :a :b :c)
      #:do ((match-define (ht a b) (compute ~))
            (define-values (x y) (baz ~ a b))
            (set ~table :a :b :d (list a b)))
      (~:meth a b)
      ;; which I think rewrites correctly as long as I either bind ~ as needed, or
      ;; maybe even better bind ~ either as local syntax parameter or id transformer
      #:with ((list m n) ~)
      ;; note that ~ does not appear anywhere below, we allow this by rewriting into
      ;; (let () accumulated-expressions (list a b x y m n)) or maybe begin instead
      ;; of let. We then continue as before with ~ expanding into that let-expr.
      (list a b x y m n))
#+end_src

Alexis' [[https://github.com/lexi-lambda/threading][threading]] library does almost exactly what I want at least with respect to
holes. I think I want more though as per example above:
1. #:guard short-circuits execution if predicate fails,
2. #:with like in syntax-classes,
3. #:do like in syntax-classes,
4. #:fail-unless and #:fail-when like guard but throw an error,
5. allow ~id holes eq to just ~ to improve readability and add context,
6. allow ~:id, ditto for . .. ::
7. allow id:~, ditto for . .. ::
8. allow ~ in app position.

If I'm honest only 5-8 aren't entirely frivolous. 1-4 maybe better served as just
your normal body with intermediate definitions.

** IDEA named lambda
CLOSED: [2019-05-18 Sat 13:37]

Allow naming lambda so that it can be rucursively called from the body:
- (nλ foo (args) body)
- (λ/n foo (args) body)

Because (lambda args body) is valid we cannot redefine lambda to take the name, so
it has to be a separate thing.

** IDEA (f a b . rest) or (f a b #:rest rest)
CLOSED: [2019-05-18 Sat 13:37]

eq to (apply f a b rest), this only works when rest is an identifier that evals to
a list, doesn't magincally work for any expr, due to how reader treats dot. Works
out for rest:id because we end up with an improper list, which we can tell from
everything else.

Better yet, and probably cleaner allow explicit #:rest keyword?

** IDEA setf => set!
CLOSED: [2019-05-18 Sat 13:37]

But leverage gen:dict interface as much as possible.

Also shift! rotate! inc! dec! push! pop!, etc.

setf needs to be a macro so it can first expand the place, which itself could be a
macro, but I wonder if the code it generates could use a generic function that a
programmer could supply? Like, generate some generic ~genset!~ that dispatches on
their type, and we could predefine those for well known types.

** IDEA let that takes (values ...) pattern
CLOSED: [2019-05-18 Sat 13:37]

First check if there is such a thing already e.g. let/match may already support
even more general destructuring.

** IDEA with-slots and with-accessors
CLOSED: [2019-05-18 Sat 13:37]

Not urgent, first I need to see actual use for that. They make for cool macros
cause they bind identifiers since Racket can do that.

* TIL in Racket

** precedence of prop:evt prop:input-port prop:output-port             :TIL:

#+begin_quote
If the structure type has more than one of prop:evt, prop:input-port, and
prop:output-port, then the prop:evt value (if any) takes precedence for
determining the instance’s behavior as an event, and the prop:input-port property
takes precedence over prop:output-port for synchronization.
#+end_quote

Basically, doesn't make a tremendous amount of sense to have those combined on the
same struct, sigh. At least as far as tables go then it's probably better to just
store events and ports as slots.

** [[file:~/Code/racket/racket/doc/syntax/transformer-helpers.html?q=normalize-definition#%2528def._%2528%2528lib._syntax%252Fdefine..rkt%2529._normalize-definition%2529%2529][normalize-definition]] to parse define-like macros                    :TIL:

** logging e.g. at macro expansion time                                :TIL:

There are loggers with the default (current-logger) and there are receivers, which
are synchronizable events so you need to asynchronously sync to receive anything
from a logger.

First, (current-logger) is usually what you want and should be the one you are
logging to. Otherwise to receive you need to create a receiver for some topic and
sync it in a loop in a separate thread. Log messages either with e.g. log-debug
and friends which take strings or with a more general log-message that may take
data, too.

Be careful when logging at macro expansion time. Receiver and its thread must run
their, not at runtime, cause expansion happens before runtime.

#+begin_src racket
  ;; assume we are logging events while expanding macros
  (begin-for-syntax
    (define receiver-thread
      (thread (λ ()
                (define macro-receiver (make-log-receiver (current-logger) 'debug 'macro))
                (let loop ()
                  (println (sync macro-receiver))
                  (loop)))))
    ;; could be useful to ensure the thread actually starts before we log anything
    (sleep 2))

  ;; now from inside the macro we could log
  (log-debug "~a" (syntax->datum #'(list (list 'options.kw options.opt) ...)))
#+end_src

It is possible to avoid starting a thread by using ~with-logging-to-port~ which is
what you want for debugging anyway:

#+begin_src racket
  (with-logging-to-port (current-output-port)
    (λ ()
      (log-debug "~a" (syntax->datum #'(list (list 'options.kw options.opt) ...))))
    'debug)
#+end_src

And of course we could simlify it:

#+begin_src racket
  (define (log v)
    (with-logging-to-port (current-output-port)
      (λ () (log-debug "~a" v))
      'debug))

  (log (syntax->datum #'(list (list 'options.kw options.opt) ...)))
#+end_src

** mutating a hash while iterating over it                        :TIL:

is it ok? As expected its dangerous and should be avoided in most circumstances.
[[https://docs.racket-lang.org/reference/hashtables.html][Per documentation]]:

#+begin_quote
A hash table can be used as a two-valued sequence (see Sequences). The keys and
values of the hash table serve as elements of the sequence (i.e., each element is
a key and its associated value). If a mapping is added to or removed from the hash
table during iteration, then an iteration step may fail with exn:fail:contract, or
the iteration may skip or duplicate keys and values. See also in-hash,
in-hash-keys, in-hash-values, and in-hash-pairs.
#+end_quote

*** [[https://groups.google.com/forum/#!topic/racket-users/L6DMOYcEFbc][asked on list]]

Is it ok to mutate a hash while iterating over it say in one of ~for~ forms?
Specifically I want to filter (that is drop) some keys, but I'm also interested in
mutation in general. I guess the answer lies in whether forms like ~in-dict~ etc
create lazy streams that hold on to the table?

Relevant docs that I managed to dig out:
- hash-map seems to suggest that at least dropping keys is fine, but that only
  talks about hash-map procedure specifically not other forms;
- caveats concerning concurrent modifications maybe kinda relevant (I've asked
  similar question about concurrency some time ago).

Here're some examples to be concrete:
#+begin_src racket
  ;; IMO ok according to docs?
  (hash-map h (λ (k v) (when (pred v) (hash-remove! h k))))

  ;; probably ok assuming it translates to hash-map?
  (dict-map h (λ (k v) (when (pred v) (dict-remove! h k))))

  ;; is that ok?
  (for (((k v) (in-dict h))
        #:when (pred v))
    (dict-remove! h k))

  ;; defensive solution
  (let ((fails (for/list (((k v) (in-dict h))
                          #:when (pred v))
                 k)))
    (for-each (curry dict-remove! h) fails))
#+end_src

** How (foo ...) expands in different situations                       :TIL:

#+begin_quote
If it is a syntax-object pair whose first element is an identifier, and if the
identifier has a binding other than as a top-level variable, then the identifier’s
binding is used to continue.
#+end_quote

while syntax pair of any other form will expand into (#%app ...), so in our foo
case into (#%app foo ...). So be careful when you test foo that's supposed to be
bound at call site but not necessarily at macro-definition site. This matters when
you are attempting to implement forms similar to #%app. I found out in the context
of #%table.

** Extract struct info from structure type transformer binding         :TIL:

see [[file:~/Code/racket/racket/doc/reference/structinfo.html?q=struct][Structure Type Transformer Binding]] in documentation

#+begin_src racket
  (struct request (foo bar))

  (begin-for-syntax
    (displayln
     (extract-struct-info
      (syntax-local-value #'request))))
#+end_src

** Where ~raco setup~ builds docs from scribblings?                    :TIL:

Basically, install packages you're hacking on in user scope with: ~raco pkg
install -u~ then docs are built local to the package dir <pkg>/docs, else setup
moves them to racket/collections.

#+begin_quote
For a collection that is installed as user-specific (e.g., the user package
scope), the generated documentation is "doc/manual/index.html" within the
collection directory. If the collection is installation-wide, however, then the
documentation is generated as "manual/index.html" in the installation’s "doc"
directory.
#+end_quote

** free-vars                                                           :TIL:

Are not vars without bindings, they are vars that are lambda- or let-bound but
outside of the expression being tested.

~(lambda (x ~) (print-body-free-vars (lambda (y) (~> 42 (list ~)))))~

so in the above x and ~ are free-vars in the inner lambda, but ~> is simply
unbound and will, upon full expansion, be wrapped in #%top.

** Struct as syntax transformer with props (e.g. prop:match-expander)  :TIL:

To avoid naming conflicts.

Basically, you can define a ~prop:match-expander~ on a struct and then bind syntax
transformer to that struct it will work as a pattern in ~match~. The cool part is
that you can also define ~prop:procedure~ in the same struct which will work as a
macro expander, so you can have both match-pattern and a macro to share the same
name. Struct must be defined ~for-syntax~. For an example see my ~ht~
implementation: when used as macro it is a hash-table constructor, but it can also
be used with no conflict inside match for pattern-matching on hash-tables.
Awesome!

Same can be achieved for ~syntax-parse~ patterns with ~prop:pattern-expander~.

I learnt this from an example in docs for ~prop:pattern-expander~.

** [[file:~/Code/racket/racket/doc/reference/stxtrans.html?q=syntax-local-lift-expression#%2528def._%2528%2528quote._~23~25kernel%2529._syntax-local-lift-expression%2529%2529][syntax-local-lift-expression]]

** syntax-parse notes

*** syntax helpers

~(require syntax/stx)~ has helpers to avoid syntax->list and syntax-e e.g.
stx-map, stx-car, stx-cdr

~replace-context~ might be helpful - borrows contexct from syntax but preserves
locations.

~(require syntax/keyword)~ Use a keyword table with ~parse-keyword-options~ to
parse keyword options. Likely a more robust approach than pattern-matching in
syntax-parse. Use ~check-expression~ or other predefined check-procedures to just
grab syntaxes that are keyword args. Same lib provides functions to extract parsed
options.

I don't really understand it but there is ~transform-template~ that e.g. lets you
preserve certain info and properties that syntax may otherwise lose, e.g.
'paren-shape. Docs offer an example. Given my interest in preserving curlies for
tables this maybe useful, but I don't understand when I would need it.

**** [[https://docs.racket-lang.org/syntax-classes/index.html][additional syntax classes]]

have ~paren-shape~, ~paren-shape/braces~ classes and ~braces pattern! Which I
could've used for my {} table constructor.

There's also class to match struct id transformers, which may tell me how to
extend gen:associative to structs. Incidentally another source of that info could
be Jay's [[https://docs.racket-lang.org/struct-define/index.html][struct-define]] (specifically, see [[https://github.com/jeapostrophe/struct-define/blob/master/main.rkt][its source]]).

*** Parsing and specifying syntax

:expr syntax class matches anything but keywords.

Optionally match with ~seq [(~seq pat ...) | (~seq)] and ~optional, then
conditionally splice with ~?, better still consider factoring out into a
(splicing) syntax class.

Always add #:name to ~optional for better error reporting.

Do not hesitate to normilize syntaxes especially when using splicing-classes that
match both single terms (e.g. clauses that are lists) and actuall sequences like
keyword followed by options.

If normalization doesn't cut it and heavy processing is to follow use
non-syntax-valued attributes i.e. use Racket compound data e.g. hash-tables or
structs to collect syntaxes as #:attr, then pull out with (attribute foo.bar).

Place additional contractual constraints with #:declare expr/c-syntax-class
combination. This effectively adds phase-0 runtime contract checks on generated
expressions.

Don't forget to use #:context parse-option for correct error reporting when
parsing fails, mostly matters when parsing some intermediate syntax we generate.

#:conventions that imports pattern-variable conventions defined with
define-conventions are pretty awesome and apparantly how Redex does its magic.

Don't forget that syntax-classes can take parameters.

Use define/syntax-parse in place of with-syntax or define/with-syntax that uses
simpler syntax-case patterns.

Create non-syntax attributes with #:attr or ~bind head pat.

Create syntax attributes with #:with or ~parse head pat.

Don't forget ~this-syntax~ is bound to stx being matched in syntax-class
definition or syntax-parse expr.

~(require syntax/parse/lib/function-header)~ provides syntax classes to match
typical function headers and formal params. Better than me rolling my own.
Attributes aren't documented but can easily see them in the source.

Some support for debugging syntax-parse and syntax classes exists:
- syntax-class-parse,
- debug-parse,
- (debug-syntax-parse!).

Quasisyntax + unsyntax are often awkward and used with syntax objects introduce
too much noise. This maybe remedied with with experimental ~template~ and
~define-template-metafunction~. Its kinda cool, I've seen this used to great
effect in Redex.

* Racket questions

** how do you read, manipulate, debug scope sets?

[[https://groups.google.com/forum/#!topic/racket-users/eF2Cy69IkHw][Asked on list]]

I wrote a macro which introduced an implicit binding <~ so that it could be used
in expressions at the use-site. Initially did it with

#+begin_src racket
  ;; inside syntax-parse
  (datum->syntax this-syntax #'<~)
#+end_src

followed by macro introduced expr that binds it, then the use-site macro-input
that uses it. Think (let/ec <~ macro-input-body).

Worked just fine when tested at top-level or module begin or in expression
position, but then suddenly broke when I wrote another define-like macro whose
body expanded into the macro above. Turns out scopes of <~ at use-site and one I
introduced in a macro didn't match, at least that's what I surmount from the
message below. I was originaly going to ask if someone could teach me to read
these messages, but then I found ~syntax-debug-info~ in docs :) and IIUC the
message below tells me there are two identifier bindings where the error occurs
whose scope-sets share some scopes namely "common scopes ...", but neither one's
scope-set is a subset of the other hence the error. Am I reading it right?

#+begin_src racket
; /Users/russki/Code/tilda/prelude/tilda.rkt:303:20: <~: unbound identifier
;   in: <~
;   context...:
;    #(2212719 use-site) #(2212754 intdef) #(2212808 local)
;    #(2212809 intdef) [common scopes]
;   other binding...:
;    local
;    #(2212718 macro) [common scopes]
;   common scopes...:
;    #(2198084 module) #(2198091 module tilda) #(2212726 local)
;    #(2212727 intdef) #(2212737 local) #(2212738 intdef) #(2212741 local)
;    #(2212742 intdef) #(2212745 local) #(2212746 intdef) #(2212749 local)
;    #(2212750 intdef) #(2212753 local)
#+end_src

I fixed the above with some guesswork that amounted to replacing datum->syntax
with

#+begin_src racket
  (syntax-local-introduce #'<~)
#+end_src

which IIUC simply flips the scopes so now <~ is use-site and may as well be part
of the macro input. Right?

Suddenly I find myself playing games with hygiene and not really knowing the
rules.

Are there any tutorials that show you how to use things documented in Syntax
Transformers chapter of the Reference?

How do you debug these scope games?

How do you introduce or capture identifier bindings (break hygiene)?

Can you temporarily unbind an identifier (for the extent of some expr), so
basically remove or trim some scopes from identifiers that occur in macro input? I
suppose there are several possible cases here:
- trim or replace scopes of ids whose sets match those at use-site, guessing this
  won't unbind "shadowing" identifiers (let or define introduced in your macro
  input) i.e. those with extra scopes in addition to use-site,
- how do we deal with those, could we trim ids whose scope sets are supersets of
  use-site?
- assuming I know how to do the above, do I walk the syntax tree and trim those
  scopes every time I find matching id or is there a better way?

At this point I'd like to better understand how to manipulate sets of scopes and
verify the result. Could someone kindly teach me or point out good reads or
examples?

Thanks


** extend Racket with new autoquoted datums ala Racket keywords

[[https://groups.google.com/d/msg/racket-users/Zp4OoVIyd1o/gkE_KolhBAAJ][Asked on list]], but somehow the message split up into two separate threads, and
Matthew and Alexis commented in the [[https://groups.google.com/d/msg/racket-users/YOyxf6oBW94/rhfkWk1IAQAJ][other thread]].

*** Problem

Basically how do you implement something like Clojure keywords, which I call tags
so that they take role similar to e.g. Racket quoted symbols or keywords:
autoquoted, self-evaluating, span all phases, cooperate with the reader, yet
expander can do something smart with them.

** bind an unbound id in a macro

[[https://groups.google.com/forum/#!topic/racket-users/ztrOjIIxSjs][Asked on list]]

*** Problem

Here's what I've been trying and failing to do in Racket. The smallest example I
could think of is a macro that sets a key in a hash-table, so basically this
transformation:

#+begin_src racket
  (set/define ht 'key 42)
  ;; =>
  (hash-set! ht 'key 42)
#+end_src

but if ht there is an unbound identifier it must bind it to a fresh hash table. So
basically introduce a (define ht (make-hash)) before setting the key. Assume we
run in a context where define is allowed.

Please, don't ask why I want something like this, I just do. So far tricks I could
use in other lisps failed in Racket. Here's one silly idea: catch unbound
identifier exn. You can do it as per below or in the handler itself but it doesn't
matter cause that define is local (I think) and doesn't happen in the macro use
context.

#+begin_src racket

  (require (only-in syntax/macro-testing convert-compile-time-error))

  (define (unbound-id-error? err)
    (and (exn:fail:syntax? err)
         (regexp-match #rx"unbound identifier" (exn-message err))))

  (define-syntax-rule (set/define id key val)
    (unless (let/ec k
              (with-handlers ((unbound-id-error? (λ (_) (k #f))))
                (convert-compile-time-error
                 (hash-set! id key val))))
      (displayln "escaped")
      (define id (make-hash))
      (hash-set! id key val)))

  (set/define ht 'key 42)
  ;; =>
  ;; runs but appears that the (define ht ..) doesn't happen at top-level

#+end_src

This is already all sorts of ugly and it doesn't even work.

Another idea is to replace #%top for the extent of that transformer, perform
local-expand (or some equivalent) so that #%top expansion does the job. I've no
idea how to do that, but I'm sure Racket could be persuaded. Incidentally, I'm
curious how to create such local transformers e.g. something like (let-transformer
((#%top ...)) body).

Even if I knew how to do the above (local-expand #'(set/define ht 'key 42) '())
run at compile time doesn't seem to wrap unbound ht in #%top. I thought it should?

So then, two questions:

1. What's the Racket way of getting what I want?

2. Is there a way to torture the above code into submission? Put differently is
   there a way to ensure (define id (make-hash)) runs in appropriate context?

** cycle in loading

[[https://groups.google.com/forum/#!topic/racket-users/DKfWFGJVckU][Asked on the list]]

*** Problem

I wrote a library foo/bar.rkt and I also allow to use it as a #lang. Roughly the
structure is like this:

foo
├── bar
│   ├── lang
│   │   └── reader.rkt
│   └── main.rkt
├── bar.rkt

Most of the work happens in the library foo/bar.rkt, so naturally all of the tests
reside there. I'd like to be able to test library proper, but also use the syntax
of the language that I defined for it, so I try something like this and get a ...
cycle? Sadly, I can't figure out why. Could you please help me reason through
this.

#+begin_src racket
  ;; foo/bar.rkt
  ;; -----------
  ;; bulk of foo/bar language semantics is here, but we also want to allow
  ;; requiring it as a library, hence this file and module indirection
  (module+ test

    (module lang-test foo/bar
      (provide run-language-tests)
      (define (run-language-tests) 42))

    (define run (dynamic-require 'lang-test 'run-language-tests))
    (run))

  ;; => error
  ;
  ; standard-module-name-resolver: cycle in loading
  ;   at path: /Users/russki/Code/foo/bar.rkt
  ;   paths:
  ;    /Users/russki/Code/prelude/bar.rkt

#+end_src

Far as I can tell cycle isn't due to dynamic-require there, but due to that
submodule declaration. This puzzles me, since the submod is declared with module,
not module+ or module*.

Other modules look as you'd probably expect:

#+begin_src racket
  ;; foo/bar/lang/reader.rkt
  ;; -----------------------
  #lang s-exp syntax/module-reader
  foo/bar/main

  ;; foo/bar/main.rkt
  ;; ----------------
  #lang racket
  (require foo
           "../bar.rkt")

  (provide (except-out (all-from-out foo) #%app #%top)
           (rename-out [app #%app]
                       [top #%top])
           (except-out (all-from-out "../bar.rkt") app top))
#+end_src


Now, if we move the lang tests into a separate file, the dynamic-require above
works out and no cycles are reported:

#+begin_src racket
;; foo/lang-test.rkt
;; -----------------
#lang foo/bar
(provide run-language-tests)
(define (run-language-tests) 42)
#+end_src

One hypothesis I have is that the (module lang-test foo/bar ...) doesn't resolve
to the language but rather to the foo/bar.rkt. There must be a way to reflect how
resolver works, but the closest I found was this:

#+begin_src racket
(require syntax/modresolve)
(resolve-module-path 'foo/bar)
#+end_src

And indeed it resolves to foo/bar.rkt, but then I don't know if I'm even using it
correctly.

I may actually be doing something stupid here e.g. introducing ambiguity as to how
foo/bar is resolved (lang or lib) but this silliness brings about some things I'd
like to clarify and learn:

1. How would you write your tests in the situation like this when most of the work
   happens in the library but you also allow using it as #lang? I'd like to keep
   both kinds of tests local to the library, so I can run them as code. Or at
   least be able to run tests that only test the lib and corresponding language.

2. Why does the above report a cycle? How do I reason about it, better still how
   do I query the resolver, reflect and debug?


Have I missed some important part in the docs about this?
